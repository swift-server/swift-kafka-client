#!/usr/bin/env python3
##===----------------------------------------------------------------------===##
##
## This source file is part of the swift-kafka-client open source project
##
## Copyright (c) YEARS Apple Inc. and the swift-kafka-client project authors
## Licensed under Apache License v2.0
##
## See LICENSE.txt for license information
## See CONTRIBUTORS.txt for the list of swift-kafka-client project authors
##
## SPDX-License-Identifier: Apache-2.0
##
##===----------------------------------------------------------------------===##

import json
import os


class _ConfigLine:
    _CLIENT_TYPES = {
        "C": "consumer",
        "P": "producer",
        "*": "both",
    }

    _INIT_TYPES = {
        "integer": int,
        "float": float,
        "boolean": bool,
    }

    _SWIFT_TYPE_MAPPING = {
        "see dedicated API": "_internal_",
        "string": "String",
        "integer": "Int",
        "float": "Double",
        "boolean": "Bool",
        "pattern list": "[String]",
        "CSV flags": "[enum]",
        "enum value": "enum",
    }

    _SWIFT_TYPE_OVERRIDES = {
        "bootstrap.servers": "[String]",
        "metadata.broker.list": "[String]",
    }

    def __init__(
        self,
        scope: str,
        name: str,
        client_type: str,
        range: str,
        default: str,
        importance: str,
        description: str,
    ):
        self.scope = scope
        self.name = name
        self.swift_name = self._get_swift_name(name)
        self.type = self._parse_type(description)
        self.swift_type = self._get_swift_type(name, self.type)
        if self.swift_type in ("enum", "[enum]"):
            self.swift_enum_name = self._get_swift_enum_type(self.swift_name)
        self.client = self._CLIENT_TYPES[client_type]

        values = self._parse_range(range)
        if values and self.type in ("integer", "float"):
            self.min_value = self._to_type(values[0])
            self.max_value = self._to_type(values[1])
        elif values and self.type in ("enum value", "CSV flags"):
            self.values = values

        self.default = self._to_type(default)
        self.importance = importance
        self.deprecated = self._is_deprecated(description)
        self.experimental = self._is_experimental(description)
        self.description = self._split_description(description)

    def _parse_type(self, description: str):
        return description.split("<br>*Type: ")[-1].strip("*")

    def _get_swift_type(self, name: str, type: str):
        if name in self._SWIFT_TYPE_OVERRIDES:
            return self._SWIFT_TYPE_OVERRIDES[name]

        return self._SWIFT_TYPE_MAPPING[type]

    def _get_swift_enum_type(self, swift_name: str):
        return f"{swift_name[0].upper()}{swift_name[1:]}"

    def _get_swift_name(self, name: str) -> str:
        initial, *rest = name.split(".")
        return initial + "".join(n.capitalize() for n in rest)

    def _is_experimental(self, description: str):
        return "**EXPERIMENTAL**" in description

    def _is_deprecated(self, description: str):
        return "**DEPRECATED**" in description

    def _parse_range(self, range: str):
        if ".." in range:
            return [p.strip() for p in range.split("..")]
        elif "," in range:
            return [p.strip() for p in range.split(",")]

    def _to_type(self, value):
        if self.type in self._INIT_TYPES:
            return self._INIT_TYPES[self.type](value)
        else:
            return value

    def _split_description(self, description: str):
        # Drop <br>Type: ...
        description = description.split(" <br>")[0]

        sentences = [
            s if s.endswith(".") else f"{s}." for s in description.split(". ") if s
        ]

        return sentences

    def to_dict(self):
        return {
            "name": self.name,
            "swiftName": self.swift_name,
            "type": self.type,
            "swiftType": self.swift_type,
            "swiftEnumName": getattr(self, "swift_enum_name", None),
            "client": self.client,
            "scope": self.scope,
            "importance": self.importance,
            "deprecated": self.deprecated,
            "experimental": self.experimental,
            "values": getattr(self, "values", None),
            "minValue": getattr(self, "min_value", None),
            "maxValue": getattr(self, "max_value", None),
            "defaultValue": self.default,
            "description": self.description,
        }


def autogenerated_warning():
    return """
// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################"""


def load_librdkafka_configs() -> list[dict]:
    dir_path = os.path.dirname(os.path.realpath(__file__))
    with open(dir_path + "/../Sources/Crdkafka/librdkafka/CONFIGURATION.md", "r") as f:
        all_lines = f.readlines()

    topic_configs_start = all_lines.index("## Topic configuration properties\n")
    global_config_lines = all_lines[:topic_configs_start]
    topic_config_lines = all_lines[topic_configs_start:]

    global_configs = _parse_md_table_lines(global_config_lines, "global")
    topic_configs = _parse_md_table_lines(topic_config_lines, "topic")

    # Add any non-duplicate topic configs to the list of global configs as
    # they can also be set on the client configuration using `rd_kafka_conf_set`
    global_config_names = set(c["name"] for c in global_configs)
    global_configs += [c for c in topic_configs if c["name"] not in global_config_names]

    return global_configs, topic_configs


def _parse_md_table_lines(table_lines: list[str], scope: str):
    rows = [line for line in table_lines if " | " in line]

    configs = []
    for line in rows:
        parts = [p.strip() for p in line.split(" | ")]
        # Skip table headers
        if parts[0] == "Property":
            continue
        config_line = _ConfigLine(scope, *parts)
        configs.append(config_line.to_dict())

    return configs


_global_librdkafka_configs, _topic_librdkafka_configs = load_librdkafka_configs()

_SKIPPED_PROPERTIES = {
    "builtin.features",
}

# Filter out internal/pointer-type, deprecated and explicitly skipped properties
global_librdkafka_configs = [
    c
    for c in _global_librdkafka_configs
    if c["swiftType"] != "_internal_"
    and not c["deprecated"]  # noqa: W503
    and c["name"] not in _SKIPPED_PROPERTIES  # noqa: W503
]

enum_types = [
    {
        "name": c["swiftEnumName"],
        "values": c["values"],
        "description": c["description"],
    }
    for c in global_librdkafka_configs
    if c["type"] in ("CSV flags", "enum value")
]

consumer_librdkafka_configs = [
    c for c in global_librdkafka_configs if c["client"] in ("consumer", "both")
]
producer_librdkafka_configs = [
    c for c in global_librdkafka_configs if c["client"] in ("producer", "both")
]


if __name__ == "__main__":
    print(json.dumps(global_librdkafka_configs))
