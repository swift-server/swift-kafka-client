//===----------------------------------------------------------------------===//
//
// This source file is part of the swift-kafka-client open source project
//
// Copyright (c) 2026 Apple Inc. and the swift-kafka-client project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of swift-kafka-client project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import *
}%
${autogenerated_warning()}

import struct Foundation.UUID

public struct KafkaConsumerConfig: Sendable {
    // MARK: - Non-librdkafka configuration properties

    /// The time between two consecutive polls.
    /// Effectively controls the rate at which incoming events and messages are consumed.
    /// Default: `.milliseconds(100)`
    public var pollInterval: Duration = .milliseconds(100)

    /// The strategy used for consuming messages.
    public var consumptionStrategy: KafkaConsumerConfiguration.ConsumptionStrategy?

    /// Consumer metrics configuration.
    public var metrics: KafkaConfiguration.ConsumerMetrics = .init()

    // MARK: - Properties generated from librdkafka config list

  % for rdconf in consumer_librdkafka_configs:
    % for description_sentence in rdconf["description"]:
    /// ${description_sentence}
    % end
    ///
    /// Importance: ${rdconf["importance"]}
    % if rdconf["minValue"]:
    ///
    /// Value range: ${rdconf["minValue"]} .. ${rdconf["maxValue"]}
    % end
    % if rdconf["values"]:
    ///
    /// Values: ${", ".join(f'`"{v}"`' for v in rdconf["values"])}
    % end
    % if rdconf["defaultValue"]:
    ///
    /// Default: ${rdconf["defaultValue"]}
    % end
    public var ${rdconf["swiftName"]}: ${rdconf["swiftType"].replace("enum", f"KafkaConfig.{rdconf["swiftEnumName"]}")}?
  % end

    public init() {}

    internal var config: [String: String] {
        var config: [String: String] = [:]

      % for rdconf in consumer_librdkafka_configs:
        % if rdconf["swiftType"] == "enum":
        config["${rdconf["name"]}"] = self.${rdconf["swiftName"]}?.rawValue
        % elif rdconf["swiftType"] == "[enum]":
        config["${rdconf["name"]}"] = self.${rdconf["swiftName"]}?.map(\.rawValue).joined(separator: ",")
        % elif rdconf["swiftType"] == "[String]":
        config["${rdconf["name"]}"] = self.${rdconf["swiftName"]}?.joined(separator: ",")${" // ignore-unacceptable-language" if rdconf["name"] == "topic.blacklist" else ""}
        % else:
        config["${rdconf["name"]}"] = self.${rdconf["swiftName"]}?.description
        % end
      % end

        if config["group.id"] == nil, let consumptionStrategy = self.consumptionStrategy?._internal {
            switch consumptionStrategy {
            case .partition(let groupID, _, _, _):
                if let groupID {
                    config["group.id"] = groupID
                } else {
                    // Although an assignment is not related to a consumer group,
                    // librdkafka requires us to set a `group.id`.
                    // This is a known issue:
                    // https://github.com/edenhill/librdkafka/issues/3261
                    config["group.id"] = UUID().uuidString
                }
            case .group(let groupID, _):
                config["group.id"] = groupID
            }
        }

        if config["statistics.interval.ms"] == nil,
            metrics.enabled,
            let updateInterval = metrics.updateInterval
        {
            config["statistics.interval.ms"] = String(updateInterval.inMilliseconds)
        }

        return config
    }

    // swift-format-ignore
    internal init(_ configDict: [String: String]) {
      % for rdconf in consumer_librdkafka_configs:
        % if rdconf["swiftType"] == "String":
        self.${rdconf["swiftName"]} = configDict["${rdconf["name"]}"]
        % elif rdconf["swiftType"] == "Int":
        self.${rdconf["swiftName"]} = Int(configDict["${rdconf["name"]}"] ?? "")
        % elif rdconf["swiftType"] == "Double":
        self.${rdconf["swiftName"]} = Double(configDict["${rdconf["name"]}"] ?? "")
        % elif rdconf["swiftType"] == "Bool":
        self.${rdconf["swiftName"]} = Bool(configDict["${rdconf["name"]}"] ?? "")
        % elif rdconf["swiftType"] == "[String]":
        self.${rdconf["swiftName"]} = configDict["${rdconf["name"]}"]?.components(separatedBy: ",")${" // ignore-unacceptable-language" if rdconf["name"] == "topic.blacklist" else ""}
        % elif rdconf["swiftType"] == "enum":
        self.${rdconf["swiftName"]} = .init(rawValue: configDict["${rdconf["name"]}"] ?? "")
        % elif rdconf["swiftType"] == "[enum]":
        self.${rdconf["swiftName"]} = configDict["${rdconf["name"]}"]?.components(separatedBy: ",").map { ${f"KafkaConfig.{rdconf["swiftEnumName"]}"}(rawValue: $0)! }
        % end
      % end
    }
}
